package SemanticSyslogSolution.SemanticSyslog;

/*Generated by MPS */

import org.d0sl.machine.SemanticModelFactory;
import org.d0sl.model.SemanticModel;
import org.d0sl.model.Use;
import org.d0sl.model.DomainSpecificModel;
import org.d0sl.model.FunctionDef;
import org.d0sl.model.expression.ExpressionType;
import org.d0sl.model.ArgumentDef;
import org.d0sl.model.PredicateDef;
import org.d0sl.model.expression.And;
import org.d0sl.model.FunctionCall;
import org.d0sl.model.expression.StringConstant;
import org.d0sl.model.ArgumentRef;
import org.d0sl.machine.LocalSemanticRegistry;
import org.d0sl.machine.ModelDescriptor;
import org.d0sl.machine.LocalSemanticMachine;
import org.d0sl.machine.PredicateDescriptor;
import org.d0sl.machine.SemanticException;

public class SemanticSyslog implements SemanticModelFactory {
  private static String name;
  private static SemanticModel model;

  static {
    name = "SemanticSyslog";
    model = new SemanticModel(name);
    // Building SemanticModel 
    addUsages(model);
    addVariables(model);
    addRules(model);
    addPredicates(model);
    System.out.println(model);
  }

  public static String getName() {
    return name;
  }
  public static SemanticModel getModel() {
    return model;
  }

  /**
   * Adds all "use" declarations to Semantic Model
   */
  public static void addUsages(SemanticModel model) {
    model.getUses().add(use_a0());
  }

  public static Use use_a0() {
    Use use = new Use();
    use.setModelName("SyslogDSL");
    use.setClassName("com.gumirov.semanticsyslog.SyslogDSL");
    use.setDomainModel(new DomainSpecificModel("SyslogDSL") {
      {
        getFunctions().add(new FunctionDef("SyslogDSL", "alert tg", null) {
          {
            String functionName = "alert tg";
            setResultType(ExpressionType.LOGICAL_CONSTANT);
            addArgument(new ArgumentDef("SyslogDSL", functionName, "adminId") {
              {
                setArgumentType(ExpressionType.STRING_CONSTANT);
              }
            });
            addArgument(new ArgumentDef("SyslogDSL", functionName, "msg") {
              {
                setArgumentType(ExpressionType.STRING_CONSTANT);
              }
            });
          }

        });
        getFunctions().add(new FunctionDef("SyslogDSL", "find regex", null) {
          {
            String functionName = "find regex";
            setResultType(ExpressionType.LIST);
            addArgument(new ArgumentDef("SyslogDSL", functionName, "regex") {
              {
                setArgumentType(ExpressionType.STRING_CONSTANT);
              }
            });
            addArgument(new ArgumentDef("SyslogDSL", functionName, "str") {
              {
                setArgumentType(ExpressionType.STRING_CONSTANT);
              }
            });
            addArgument(new ArgumentDef("SyslogDSL", functionName, "group") {
              {
                setArgumentType(ExpressionType.NUMERIC_CONSTANT);
              }
            });
          }

        });
        getFunctions().add(new FunctionDef("SyslogDSL", "start", null) {
          {
            String functionName = "start";
            setResultType(ExpressionType.LOGICAL_CONSTANT);
            addArgument(new ArgumentDef("SyslogDSL", functionName, "callback predicate name") {
              {
                setArgumentType(ExpressionType.STRING_CONSTANT);
              }
            });
          }

        });
      }
    });
    return use;
  }

  /**
   * Adds all global variables to Semantic Model
   */
  public static void addVariables(SemanticModel model) {
  }


  /**
   * Adds all rules to Semantic Model
   */
  public static void addRules(SemanticModel model) {
  }


  /**
   * Adds all predicates definitions to Semantic Model
   */
  public static void addPredicates(SemanticModel model) {
    model.addPredicateDef(predicate_c0());
    model.addPredicateDef(predicate_e0());
  }

  public static PredicateDef predicate_c0() {
    PredicateDef res = new PredicateDef("SemanticSyslog", "parse line", new And() {
      {
        addOperand(new FunctionCall() {
          {
            setModelName("SyslogDSL");
            setFunctionName("alert tg");
            addOperand(new StringConstant("aaa"));
            addOperand(new ArgumentRef("SemanticSyslog", "parse line", "line"));
          }
        });
      }
    }, new ArgumentDef("SemanticSyslog", "parse line", "line") {
      {
        setArgumentType(ExpressionType.STRING_CONSTANT);
      }
    }) {
      {
      }
    };
    return res;
  }
  public static PredicateDef predicate_e0() {
    PredicateDef res = new PredicateDef("SemanticSyslog", "start", new And() {
      {
        addOperand(new FunctionCall() {
          {
            setModelName("SyslogDSL");
            setFunctionName("start");
            addOperand(new StringConstant("parse line"));
          }
        });
      }
    }) {
      {
      }
    };
    return res;
  }

  public static void main(String[] args) {
    // Runing start() predicate if it exists 
    LocalSemanticRegistry registry = new LocalSemanticRegistry();
    try {
      ModelDescriptor md = registry.register(model);
      LocalSemanticMachine machine = (LocalSemanticMachine) registry.getSemanticMachine(md);

      machine.loadBaseLibrary("com.gumirov.semanticsyslog.SyslogDSL");

      PredicateDescriptor[] predicates = machine.getPredicatesList();
      PredicateDescriptor start = null;
      for (PredicateDescriptor pdesc : predicates) {
        System.out.println(pdesc);
        if (pdesc.getPredicateName().equals("start")) {
          start = pdesc;
        }
      }
      if (start != null) {
        System.out.println(machine.callPredicate("start"));
      }
    } catch (SemanticException ex) {
      ex.printStackTrace();
    }


  }

  @Override
  public SemanticModel getSemanticModel() {
    return getModel();
  }
  @Override
  public String getModelName() {
    return getName();
  }
}
